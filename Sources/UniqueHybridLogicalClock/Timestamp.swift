#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

/// A unique timestamp generated by a Hybrid Logical Clock.
///
/// A `Timestamp` combines physical time with a logical counter and a unique identifier
/// to ensure total ordering of events across distributed systems.
///
/// ## Example
/// ```swift
/// let hlc = HybridLogicalClock()
/// let timestamp = hlc.newTimestamp()
/// print("Timestamp: \(timestamp)")
/// ```
public struct Timestamp: Sendable {
    /// The physical time component as nanoseconds since epoch
    public let time: UInt64
    
    /// The logical counter for ordering events with identical physical time
    public let logicalTime: UInt64
    
    /// The unique identifier of the clock that generated this timestamp
    public let id: UUID
    
    /// Creates a new timestamp with the given components
    /// - Parameters:
    ///   - time: Physical time in nanoseconds since epoch
    ///   - logicalTime: Logical counter value
    ///   - id: Unique identifier of the generating clock
    public init(time: UInt64, logicalTime: UInt64, id: UUID) {
        self.time = time
        self.logicalTime = logicalTime
        self.id = id
    }
}

// MARK: - Comparable

extension Timestamp: Comparable {
    /// Compares two timestamps according to Hybrid Logical Clock ordering rules.
    ///
    /// Timestamps are ordered first by physical time, then by logical time,
    /// and finally by unique identifier to ensure total ordering.
    ///
    /// ## Example
    /// ```swift
    /// let ts1 = Timestamp(time: 100, logicalTime: 0, id: UUID())
    /// let ts2 = Timestamp(time: 101, logicalTime: 0, id: UUID())
    /// assert(ts1 < ts2)
    /// ```
    public static func < (lhs: Timestamp, rhs: Timestamp) -> Bool {
        if lhs.time != rhs.time {
            return lhs.time < rhs.time
        }
        if lhs.logicalTime != rhs.logicalTime {
            return lhs.logicalTime < rhs.logicalTime
        }
        return lhs.id.uuidString < rhs.id.uuidString
    }
    
    public static func == (lhs: Timestamp, rhs: Timestamp) -> Bool {
        return lhs.time == rhs.time && 
               lhs.logicalTime == rhs.logicalTime && 
               lhs.id == rhs.id
    }
}

// MARK: - Hashable

extension Timestamp: Hashable {
    public func hash(into hasher: inout Hasher) {
        hasher.combine(time)
        hasher.combine(logicalTime)
        hasher.combine(id)
    }
}

// MARK: - CustomStringConvertible

extension Timestamp: CustomStringConvertible {
    public var description: String {
        return "Timestamp(time: \(time), logicalTime: \(logicalTime), id: \(id.uuidString.prefix(8))...)"
    }
}

// MARK: - Codable

extension Timestamp: Codable {
    private enum CodingKeys: String, CodingKey {
        case time
        case logicalTime
        case id
    }
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        time = try container.decode(UInt64.self, forKey: .time)
        logicalTime = try container.decode(UInt64.self, forKey: .logicalTime)
        id = try container.decode(UUID.self, forKey: .id)
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(time, forKey: .time)
        try container.encode(logicalTime, forKey: .logicalTime)
        try container.encode(id, forKey: .id)
    }
}